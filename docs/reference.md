# Introduction

This document is the primary reference for the **Event** programming language. It
describes each language construct.

This document does not serve as an introduction to the language itself.

# Input format

**Event** is interpreted as a sequence of ASCII characters. Every **statement**
has to be closed with a semicolon (```;```).

**Statements** are marked with the
tag ```Stamement``` across this document.

The following keywords are forbidden to use as identifiers and types:

- event
- extends
- predicate

The top level input sequence are **statements** terminated with a semicolon
(```;```).

# Comments

Comments in **Event** follow the C89 style comments. Starting with ```/*``` and
ending with ```*/```.

    <code>
    /* commented out block /*
    <code>

# Whitespaces

The interpretation of **Event** allows to use the following list of whitespaces:

- space, ' '
- tab, '\t'
- LF, '\n'
- CR, '\r'

# Identifiers

Identifiers are defined as follows:

- The first character has to be a small cased letter between a and z (```[a-z]```)
- The remaining characters can be small and capital letters, numbers and
underscores (```[a-zA-Z0-9_]*```)

# Types

Types for **Event** are defined as follows:

- The first character has to be a capital letter between A and Z (```[A-Z]```)
- The remaining characters can be small and capital letters, numbers and
underscores (```[a-zA-Z0-9_]*```)

# Numbers

**Event** handles numbers of the type ```double``` as defined by the used operating
system. They are defined as follows:

- The first line of characters have to be digits between 0 and 9 (```[0-9]+```)
- The remaining characters are optional and have to start with a dot (```.```)
followed by at least one digit (```(\.[0-9]+)?```)

# Vectors

Vectors are defined as a list of numbers, separated by commas and can only
contain numbers as a result of a given expression. The list is encapsulated by
square brackets (```[]```). e.g.

    [42]
    [1, 2, 1 + 2]

It is not possible to stack vectors into other vectors.

# Comparisons

In **Event**, you can only compare vectors. The following comparisons are
possible:

- Equal (```v1 == v2```)
- Not Equal (```v1 != v2```)
- Less than, every member (```v1 < v2```)
- Greater that, every member (```v1 > v2```)

# Operations

Like comparisons, operation can also operate only on vectors. Following
operations are possible, based on vector math:

- Addition (```v1 + v2```)
- Difference (```v1 - v2```)
- Scalar multiplication (```s * v```)

Inside a vector as a member more mathematical operations are possible. Every
member operation is an expression which has to result in number. The following
operations are possible:

- Addition (```s1 + s2```)
- Difference (```s1 - s2```)
- Multiplication (```s1 * s2```)
- Division (```s1 / s2```)

Multiplication and division have precedence over addition and difference.
Parenthesis (```()```) are possible to change the precedence.

# Events

```Statement```

Events are containers for related information. One event can extend another one
by using the keyword ```extends```. The event declaration has the following
structure:

- An event has to start with the keyword ```event``` followed by a whitespaces
- The second part has to be a ```Type``` as referred above

The third part and the fourth part are optional for event inheritance.

- The keyword ```extends```
- ```Type``` of the extended event

The following parts are mandatory and define a comma separated list of event
members holding the actual information and are encapsulated by curly braces
(```{}```).

- Opening curly brace ```{```
- Comma separated list of identifiers as described above
- Closing curly brace ```}```

Example:

    event SampleEvent { position, time };
    event RangeEvent extends SampleEvent { range };

For inheritance, only new members are allowed to be added in the inherited
event. It is forbidden to declare the same member in both, the event and it's
inheritance.

# Predicate

```Statement```

Predicates are operating on events passed to them. They return either
```False``` or ```True```. The return value is generated by the comparison
applied to the predicate.
