{
    "docs": [
        {
            "location": "/", 
            "text": "Event\n\n\nIntroduction\n\n\nEvent\n is a language for \nrule based complex-event processing on distributed networks\n.\nIt was designed to build a bridge between the C level interface\nof event generating systems like sensors or actuators and the need for a\nhigh level representation for event based systems. It provides the ability to\ndescribe the processing of events on a higher level than fiddling with C or C++ code.\n\n\nThe Event Language is a compiled language. Therefore machine code is\ngenerated during the process of compilation. This is achieved by using the LLVM\ncompiler collection, which provides us with a high level interface for\ngenerating machine code for nearly all platforms supported by LLVM. LLVM is the\ncode generation backend for our event language front end.\n\n\nExample\n\n\nFrom (\nEvent\n):\n\n\nevent SampleEvent { position, time };\n\npredicate p_position(SampleEvent a, SampleEvent b) := a.position \n b.position;\n\nSampleEvent transform(SampleEvent a, SampleEvent b) :=\n{\n    position = a.position + b.position,\n    time = a.time + b.time\n};\n\nTransform: [SampleEvent, SampleEvent : p_position] -\n transform;\n\n\n\nTo (\nC\n):\n\n\nint Transform_active(SampleEvent *, SampleEvent *);\n\nSampleEvent *Transform_function(SampleEvent *, SampleEvent *);", 
            "title": "Home"
        }, 
        {
            "location": "/#event", 
            "text": "", 
            "title": "Event"
        }, 
        {
            "location": "/#introduction", 
            "text": "Event  is a language for  rule based complex-event processing on distributed networks .\nIt was designed to build a bridge between the C level interface\nof event generating systems like sensors or actuators and the need for a\nhigh level representation for event based systems. It provides the ability to\ndescribe the processing of events on a higher level than fiddling with C or C++ code.  The Event Language is a compiled language. Therefore machine code is\ngenerated during the process of compilation. This is achieved by using the LLVM\ncompiler collection, which provides us with a high level interface for\ngenerating machine code for nearly all platforms supported by LLVM. LLVM is the\ncode generation backend for our event language front end.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#example", 
            "text": "From ( Event ):  event SampleEvent { position, time };\n\npredicate p_position(SampleEvent a, SampleEvent b) := a.position   b.position;\n\nSampleEvent transform(SampleEvent a, SampleEvent b) :=\n{\n    position = a.position + b.position,\n    time = a.time + b.time\n};\n\nTransform: [SampleEvent, SampleEvent : p_position] -  transform;  To ( C ):  int Transform_active(SampleEvent *, SampleEvent *);\n\nSampleEvent *Transform_function(SampleEvent *, SampleEvent *);", 
            "title": "Example"
        }, 
        {
            "location": "/about/license/", 
            "text": "License\n\n\nThe MIT License (MIT)\n\n\nCopyright (c) 2015 Andreas Pfohl and Robert Heum\u00fcller\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/about/license/#license", 
            "text": "The MIT License (MIT)  Copyright (c) 2015 Andreas Pfohl and Robert Heum\u00fcller  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/guides/getting_started/", 
            "text": "Getting Started\n\n\nPrerequisites\n\n\nThe \nEvent Compiler\n relies on a working installation of LLVM.  For Linux and OSX operating systems LLVM is easily installed using the package manager. For other\nenvironments check \nllvm.org\n\n\nWe currently use \nversion 3.6.1\n\n\nCompiling the Compiler\n\n\nBefore we can get started using the \nEvent Compiler\n, the source code needs to\nbe acquired and compiled. The simplest way of accomplishing this is to clone\ndirectly from the \ngit repository\n:\n\n\ngit clone git@github.com:compiler-dept/event-compiler.git\n\n\n\nNext, we navigate into the compiler's root directory. There, we fetch the external dependencies and start compilation by running the following commands:\n\n\ncd event-compiler\nmake getexternals\nmake\n\n\n\n\nIt's as simple as that: Your compiler is up and running!\n\n\nCompiling Event Sources\n\n\nFollowing the setup steps should have left you with the compiler binary \nevc\n.\nThis section explains how the compiler is used to compile \nEvent\n sources to\nplatform specific assembler files.\n\n\nAn example of a basic \nEvent\n source file is located in examples/simple.ev.\nThe \n.ev\n file extension is a convention, meaning you may use any other ending\nof your choice. Compilation is a two-step process:\n\n\n\n\nGenerating llvm bytecode from the source file with \nevc\n\n\nCompiling the llvm bytecode to a platform-specific assembler file with \nllc\n.\n\n\n\n\ncd examples\n./evc -i simple.ev -o simple.bc # writes bytecode to simple.bc\nllc simple.bc # writes platform-specifc assembler to simple.s\n\n\n\n\nCommandline Parameters\n\n\n\n\n-i \nfile\n Specify input file\n\n\n-o \nfile\n Specify output file; When missing dump llvm intermediate code to stdout\n\n\n-a \nfile\n Dump lisp-like representation of the ast to file\n\n\n-V\n Disable source validation; Use with caution: Compiling invalid code will probably lead to unexpected behavior\n\n\n-C\n Disable code generation\n\n\n-h\n Show help\n\n\n\n\nCross Compiling\n\n\nBy default, \nllc\n generates assembler specific to your native machine. If you\nwish to cross-compile for a different architecture, you may specify the target\nusing \nllc\n's \n-mtriple\n commandline parameter. For further information\nrefer to the \nllc\n manpage.\n\n\nCalling the Native Code\n\n\nThe previous sections explained how to use the \nEvent Compiler\n process \nEvent\n\nsource files into platform-specific assembler files. This section explains how\nto actually call the contained code from within a simple c application.\n\n\nInferring Prototypes\n\n\nAs explained in \nConcept\n, the compiler generates native code containing\nmethods and struct definitions for each \nrule\n defined in the \nEvent\n source code.\n\n\nThe following methods are created for each rule:\n\n\n\n\nAn activation function which returns an integer greater than zero if and only if predicates indicate the rule should be applied.\n\n\nA processing function which uses the rule's parameters to generate a new event.\n\n\n\n\nint \nrule_name\n_active(struct MyEventType1 *event1, ..., struct MyEventTypeN *eventn)\nstruct MyReturnEvent *\nrule_name\n_function(struct MyEventType1 *event1, ..., struct MyEventTypeN *eventn)\n\n\n\n\nFor every event definition a struct is created. Since the members of our events are\nvectors, each member is represented by an integer indicating its length and a pointer\nto an accordingly sized array of double values.\n\n\nstruct __attribute__((__packed__)) MyEventType1 {\n    int16_t pos_len;\n    double *pos;\n    int16_t time_len;\n    double *time;\n};\n\n\n\n\nEvent inheritance is handled simply by prepending inherited fields to the struct.\nTherefore:\n\n\nevent Parent { pos };\nevent Child extends Parent { time };\n\n\n\n\nResults in:\n\n\nstruct __attribute__((__packed__)) Parent {\n    int16_t pos_len;\n    double *pos;\n};\n\nstruct __attribute__((__packed__)) Child {\n    int16_t pos_len;\n    double *pos;\n    int16_t time_len;\n    double *time;\n};\n\n\n\n\nBoth method prototypes and event struct definitions must be declared in the\ncalling program, in order to be linked against later.\n\n\nCompiling and Linking\n\n\nExamples/simple.c contains a small program which uses the events and rules declared\nin examples/simple.ev. The inferred prototypes are located in examples/simple.h.\nIn order to compile and link the program, ensure that you have followed the previous\nsteps to compile the \nEvent\n source. Execute the following commands to compile\nand link the example:\n\n\ncd examples\ngcc -o example example.c simple.s ../src/operators.c # clang works just as well\n\n\n\n\nThe additional source file \n../src/operators.c\n contains \nEvent\n's standard\nlibrary for vector arithmetics and is therefore required for the program to compile.\n\n\nRun the example by executing:\n\n\n./example\n\n\n\n\nIf everything worked out correctly, you should get the following output:\n\n\nVector 1 [3]:\nValue 4.000000\nValue 8.000000\nValue 12.000000\nVector 2 [1]:\nValue 0.493800", 
            "title": "Getting started"
        }, 
        {
            "location": "/guides/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/guides/getting_started/#prerequisites", 
            "text": "The  Event Compiler  relies on a working installation of LLVM.  For Linux and OSX operating systems LLVM is easily installed using the package manager. For other\nenvironments check  llvm.org  We currently use  version 3.6.1", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/guides/getting_started/#compiling-the-compiler", 
            "text": "Before we can get started using the  Event Compiler , the source code needs to\nbe acquired and compiled. The simplest way of accomplishing this is to clone\ndirectly from the  git repository :  git clone git@github.com:compiler-dept/event-compiler.git  Next, we navigate into the compiler's root directory. There, we fetch the external dependencies and start compilation by running the following commands:  cd event-compiler\nmake getexternals\nmake  It's as simple as that: Your compiler is up and running!", 
            "title": "Compiling the Compiler"
        }, 
        {
            "location": "/guides/getting_started/#compiling-event-sources", 
            "text": "Following the setup steps should have left you with the compiler binary  evc .\nThis section explains how the compiler is used to compile  Event  sources to\nplatform specific assembler files.  An example of a basic  Event  source file is located in examples/simple.ev.\nThe  .ev  file extension is a convention, meaning you may use any other ending\nof your choice. Compilation is a two-step process:   Generating llvm bytecode from the source file with  evc  Compiling the llvm bytecode to a platform-specific assembler file with  llc .   cd examples\n./evc -i simple.ev -o simple.bc # writes bytecode to simple.bc\nllc simple.bc # writes platform-specifc assembler to simple.s  Commandline Parameters   -i  file  Specify input file  -o  file  Specify output file; When missing dump llvm intermediate code to stdout  -a  file  Dump lisp-like representation of the ast to file  -V  Disable source validation; Use with caution: Compiling invalid code will probably lead to unexpected behavior  -C  Disable code generation  -h  Show help   Cross Compiling  By default,  llc  generates assembler specific to your native machine. If you\nwish to cross-compile for a different architecture, you may specify the target\nusing  llc 's  -mtriple  commandline parameter. For further information\nrefer to the  llc  manpage.", 
            "title": "Compiling Event Sources"
        }, 
        {
            "location": "/guides/getting_started/#calling-the-native-code", 
            "text": "The previous sections explained how to use the  Event Compiler  process  Event \nsource files into platform-specific assembler files. This section explains how\nto actually call the contained code from within a simple c application.  Inferring Prototypes  As explained in  Concept , the compiler generates native code containing\nmethods and struct definitions for each  rule  defined in the  Event  source code.  The following methods are created for each rule:   An activation function which returns an integer greater than zero if and only if predicates indicate the rule should be applied.  A processing function which uses the rule's parameters to generate a new event.   int  rule_name _active(struct MyEventType1 *event1, ..., struct MyEventTypeN *eventn)\nstruct MyReturnEvent * rule_name _function(struct MyEventType1 *event1, ..., struct MyEventTypeN *eventn)  For every event definition a struct is created. Since the members of our events are\nvectors, each member is represented by an integer indicating its length and a pointer\nto an accordingly sized array of double values.  struct __attribute__((__packed__)) MyEventType1 {\n    int16_t pos_len;\n    double *pos;\n    int16_t time_len;\n    double *time;\n};  Event inheritance is handled simply by prepending inherited fields to the struct.\nTherefore:  event Parent { pos };\nevent Child extends Parent { time };  Results in:  struct __attribute__((__packed__)) Parent {\n    int16_t pos_len;\n    double *pos;\n};\n\nstruct __attribute__((__packed__)) Child {\n    int16_t pos_len;\n    double *pos;\n    int16_t time_len;\n    double *time;\n};  Both method prototypes and event struct definitions must be declared in the\ncalling program, in order to be linked against later.  Compiling and Linking  Examples/simple.c contains a small program which uses the events and rules declared\nin examples/simple.ev. The inferred prototypes are located in examples/simple.h.\nIn order to compile and link the program, ensure that you have followed the previous\nsteps to compile the  Event  source. Execute the following commands to compile\nand link the example:  cd examples\ngcc -o example example.c simple.s ../src/operators.c # clang works just as well  The additional source file  ../src/operators.c  contains  Event 's standard\nlibrary for vector arithmetics and is therefore required for the program to compile.  Run the example by executing:  ./example  If everything worked out correctly, you should get the following output:  Vector 1 [3]:\nValue 4.000000\nValue 8.000000\nValue 12.000000\nVector 2 [1]:\nValue 0.493800", 
            "title": "Calling the Native Code"
        }, 
        {
            "location": "/guides/language_reference/", 
            "text": "Language Reference\n\n\nIntroduction\n\n\nThis document is the primary reference for the \nEvent\n programming language. It\ndescribes each language construct.\n\n\nThis document does not serve as an introduction to the language itself.\n\n\nInput format\n\n\nEvent\n is interpreted as a sequence of ASCII characters. Every \nstatement\n\nhas to be closed with a semicolon (\n;\n).\n\n\nStatements\n are marked with the\ntag \nStamement\n across this document.\n\n\nThe following keywords are forbidden to use as identifiers and types:\n\n\n\n\nevent\n\n\nextends\n\n\npredicate\n\n\n\n\nThe top level input sequence are \nstatements\n terminated with a semicolon\n(\n;\n).\n\n\nComments\n\n\nComments in \nEvent\n follow the C89 style comments. Starting with \n/*\n and\nending with \n*/\n.\n\n\ncode\n\n/* commented out block /*\n\ncode\n\n\n\n\nWhitespaces\n\n\nThe interpretation of \nEvent\n allows to use the following list of whitespaces:\n\n\n\n\nspace, ' '\n\n\ntab, '\\t'\n\n\nLF, '\\n'\n\n\nCR, '\\r'\n\n\n\n\nIdentifiers\n\n\nIdentifiers are defined as follows:\n\n\n\n\nThe first character has to be a small cased letter between a and z (\n[a-z]\n)\n\n\nThe remaining characters can be small and capital letters, numbers and\nunderscores (\n[a-zA-Z0-9_]*\n)\n\n\n\n\nExample:\n\n\nanIdentifier_42\n\n\n\nTypes\n\n\nTypes for \nEvent\n are defined as follows:\n\n\n\n\nThe first character has to be a capital letter between A and Z (\n[A-Z]\n)\n\n\nThe remaining characters can be small and capital letters, numbers and\nunderscores (\n[a-zA-Z0-9_]*\n)\n\n\n\n\nExample:\n\n\nAType_23\n\n\n\nNumbers\n\n\nEvent\n handles numbers of the type \ndouble\n as defined by the used operating\nsystem. They are defined as follows:\n\n\n\n\nThe first line of characters have to be digits between 0 and 9 (\n[0-9]+\n)\n\n\nThe remaining characters are optional and have to start with a dot (\n.\n)\nfollowed by at least one digit (\n(\\.[0-9]+)?\n)\n\n\n\n\nExample:\n\n\n42\n1.337\n\n\n\nVectors\n\n\nVectors are defined as a list of numbers, separated by commas and can only\ncontain numbers as a result of a given expression. The list is encapsulated by\nsquare brackets (\n[]\n).\n\n\nExample:\n\n\n[42]\n[1, 2, 1 + 2]\n\n\n\nIt is not possible to stack vectors into other vectors.\n\n\nComparisons\n\n\nIn \nEvent\n, you can only compare vectors. The following comparisons are\npossible:\n\n\n\n\nEqual (\nv1 == v2\n)\n\n\nNot Equal (\nv1 != v2\n)\n\n\nLess than, every member (\nv1 \n v2\n)\n\n\nGreater that, every member (\nv1 \n v2\n)\n\n\n\n\nExample:\n\n\nevent1.pos == event2.pos\nevent1.time \n event2.time\n\n\n\nOperations\n\n\nLike comparisons, operation can also operate only on vectors. Following\noperations are possible, based on vector math:\n\n\n\n\nAddition (\nv1 + v2\n)\n\n\nDifference (\nv1 - v2\n)\n\n\nScalar multiplication (\ns * v\n)\n\n\n\n\nExample:\n\n\nevent.pos + [1, 2, 3]\n[1, 2] - [3, 4]\n6 * event.time\n\n\n\nInside a vector as a member more mathematical operations are possible. Every\nmember operation is an expression which has to result in number. The following\noperations are possible:\n\n\n\n\nAddition (\ns1 + s2\n)\n\n\nDifference (\ns1 - s2\n)\n\n\nMultiplication (\ns1 * s2\n)\n\n\nDivision (\ns1 / s2\n)\n\n\nNegation (\n-s\n)\n\n\n\n\nMultiplication and division have precedence over addition and difference.\nParenthesis (\n()\n) are possible to change the precedence.\n\n\nExample:\n\n\n1 + 1\n4 - 3\n2 * 7\n13 / 3\n-42\n(1 + 2) * 3\n\n\n\nEvents\n\n\nStatement\n\n\nEvents are containers for related information. One event can extend another one\nby using the keyword \nextends\n. The event declaration has the following\nstructure:\n\n\n\n\nAn event has to start with the keyword \nevent\n followed by a whitespaces\n\n\nThe second part has to be a \nType\n as referred above\n\n\n\n\nThe third part and the fourth part are optional for event inheritance.\n\n\n\n\nThe keyword \nextends\n\n\nType\n of the extended event\n\n\n\n\nThe following parts are mandatory and define a comma separated list of event\nmembers holding the actual information and are encapsulated by curly braces\n(\n{}\n).\n\n\n\n\nOpening curly brace \n{\n\n\nComma separated list of identifiers as described above\n\n\nClosing curly brace \n}\n\n\n\n\nExample:\n\n\nevent SampleEvent { position, time };\nevent RangeEvent extends SampleEvent { range };\n\n\n\nFor inheritance, only new members are allowed to be added in the inherited\nevent. It is forbidden to declare the same member in both, the event and it's\ninheritance.\n\n\nTo define an event with content, you enclose the information with curly braces.\n\n\n\n\nOpening curly brace (\n{\n)\n\n\n\n\nThe following is a comma separated list:\n\n\n\n\nIdentifier\n\n\nEqual sign (\n=\n)\n\n\n\n\nVector\n\n\n\n\n\n\nClosing curly brace (\n}\n)\n\n\n\n\n\n\nExample:\n\n\n{\n    position = event_a.position + event_b.position,\n    time = event_a.time + [1.34]\n}\n\n\n\nPredicates\n\n\nStatement\n\n\nPredicates are operating on events passed to them. They return either\n\nFalse\n or \nTrue\n. The return value is generated by the comparison\napplied to the predicate. A predicate has to take at least on event as an\nargument. The expression assigned to the predicate has to be a single comparison\nas described above. Predicates are created as below:\n\n\n\n\nA predicate has to start with the keyword \npredicate\n followed by a\nwhitespace\n\n\nThe second is an \nidentifier\n to name the predicate\n\n\nOpening parenthesis to begin the list of arguments (\n(\n)\n\n\n\n\nArguments are a comma separated list of tuples made out of a \ntype\n and an\n\nidentifier\n. Arguments are defined as follows:\n\n\n\n\nType\n as described above\n\n\nIdentifier\n as described above\n\n\n\n\nBack to the argument list.\n\n\n\n\nClosing parenthesis to end the list of arguments (\n)\n)\n\n\n\n\nTo separate the predicate definition from it's comparison expression, \n\"define\"\n\n(\n:=\n) is used.\n\n\n\n\nDefine sign (\n:=\n)\n\n\nComparison as explained above\n\n\n\n\nExample:\n\n\npredicate a_predicate(SampleEvent e) := e.position == [1, 1, 1];\npredicate b_predicate(SampleEvent e, RangeEvent r) := e.position != r.position;\n\n\n\nFunctions\n\n\nStatement\n\n\nFunctions are also operating on events passed to them. A function must have a\nreturn type. Functions are created as follows:\n\n\n\n\nA function starts with a \ntype\n as described earlier\n\n\nThe second is an \nidentifier\n which names the function\n\n\nOpening parenthesis to begin the list of arguments (\n(\n)\n\n\n\n\nArguments are a comma separated list of tuples made out of a \ntype\n and an\n\nidentifier\n and optional. Arguments are defined as follows:\n\n\n\n\nType\n as described above\n\n\nIdentifier\n as described above\n\n\n\n\nBack to the argument list.\n\n\n\n\nClosing parenthesis to end the list of arguments (\n)\n)\n\n\n\n\nTo separate the function definition from it's expression block, \n\"define\"\n\n(\n:=\n) is used.\n\n\n\n\nDefine sign (\n:=\n)\n\n\nExpression as described below\n\n\n\n\nAn expression can be one of the following:\n\n\n\n\nFunction call (\nf(x)\n)\n\n\nEvent (\n{ position = [1, 2, 3] }\n)\n\n\n\n\nExample:\n\n\nSampleEvent function_a(SampleEvent event_a) := {\n    position = event_a.position + [1, 0, 0],\n    time = 6 * event_a.time\n}\n\nSampleEvent function_b(SampleEvent e) := function_a(e);\n\n\n\nRules\n\n\nRules take a list of event \ntypes\n, a list of predicates and a call function.\n\n\n\n\nA \ntype\n as rule name\n\n\nColon (\n:\n)\n\n\nOpening square bracket (\n[\n)\n\n\n\n\nThe following is optional:\n\n\n\n\nComma separated list of event types (\nEventA, EventB, ...\n)\n\n\n\n\nThe following is optional:\n\n\n\n\nColon (\n:\n)\n\n\nComma separated list of predicate name \nidentifiers\n\n\n\n\nThe following is mandatory:\n\n\n\n\nClosing square bracket (\n]\n)\n\n\nRight arrow (\n-\n)\n\n\nFunction name identifier (\nfunction_a\n)\n\n\n\n\nExample:\n\n\nRuleA: [SampleEvent : a_predicate] -\n function_b;", 
            "title": "Language reference"
        }, 
        {
            "location": "/guides/language_reference/#language-reference", 
            "text": "", 
            "title": "Language Reference"
        }, 
        {
            "location": "/guides/language_reference/#introduction", 
            "text": "This document is the primary reference for the  Event  programming language. It\ndescribes each language construct.  This document does not serve as an introduction to the language itself.", 
            "title": "Introduction"
        }, 
        {
            "location": "/guides/language_reference/#input-format", 
            "text": "Event  is interpreted as a sequence of ASCII characters. Every  statement \nhas to be closed with a semicolon ( ; ).  Statements  are marked with the\ntag  Stamement  across this document.  The following keywords are forbidden to use as identifiers and types:   event  extends  predicate   The top level input sequence are  statements  terminated with a semicolon\n( ; ).", 
            "title": "Input format"
        }, 
        {
            "location": "/guides/language_reference/#comments", 
            "text": "Comments in  Event  follow the C89 style comments. Starting with  /*  and\nending with  */ .  code \n/* commented out block /* code", 
            "title": "Comments"
        }, 
        {
            "location": "/guides/language_reference/#whitespaces", 
            "text": "The interpretation of  Event  allows to use the following list of whitespaces:   space, ' '  tab, '\\t'  LF, '\\n'  CR, '\\r'", 
            "title": "Whitespaces"
        }, 
        {
            "location": "/guides/language_reference/#identifiers", 
            "text": "Identifiers are defined as follows:   The first character has to be a small cased letter between a and z ( [a-z] )  The remaining characters can be small and capital letters, numbers and\nunderscores ( [a-zA-Z0-9_]* )   Example:  anIdentifier_42", 
            "title": "Identifiers"
        }, 
        {
            "location": "/guides/language_reference/#types", 
            "text": "Types for  Event  are defined as follows:   The first character has to be a capital letter between A and Z ( [A-Z] )  The remaining characters can be small and capital letters, numbers and\nunderscores ( [a-zA-Z0-9_]* )   Example:  AType_23", 
            "title": "Types"
        }, 
        {
            "location": "/guides/language_reference/#numbers", 
            "text": "Event  handles numbers of the type  double  as defined by the used operating\nsystem. They are defined as follows:   The first line of characters have to be digits between 0 and 9 ( [0-9]+ )  The remaining characters are optional and have to start with a dot ( . )\nfollowed by at least one digit ( (\\.[0-9]+)? )   Example:  42\n1.337", 
            "title": "Numbers"
        }, 
        {
            "location": "/guides/language_reference/#vectors", 
            "text": "Vectors are defined as a list of numbers, separated by commas and can only\ncontain numbers as a result of a given expression. The list is encapsulated by\nsquare brackets ( [] ).  Example:  [42]\n[1, 2, 1 + 2]  It is not possible to stack vectors into other vectors.", 
            "title": "Vectors"
        }, 
        {
            "location": "/guides/language_reference/#comparisons", 
            "text": "In  Event , you can only compare vectors. The following comparisons are\npossible:   Equal ( v1 == v2 )  Not Equal ( v1 != v2 )  Less than, every member ( v1   v2 )  Greater that, every member ( v1   v2 )   Example:  event1.pos == event2.pos\nevent1.time   event2.time", 
            "title": "Comparisons"
        }, 
        {
            "location": "/guides/language_reference/#operations", 
            "text": "Like comparisons, operation can also operate only on vectors. Following\noperations are possible, based on vector math:   Addition ( v1 + v2 )  Difference ( v1 - v2 )  Scalar multiplication ( s * v )   Example:  event.pos + [1, 2, 3]\n[1, 2] - [3, 4]\n6 * event.time  Inside a vector as a member more mathematical operations are possible. Every\nmember operation is an expression which has to result in number. The following\noperations are possible:   Addition ( s1 + s2 )  Difference ( s1 - s2 )  Multiplication ( s1 * s2 )  Division ( s1 / s2 )  Negation ( -s )   Multiplication and division have precedence over addition and difference.\nParenthesis ( () ) are possible to change the precedence.  Example:  1 + 1\n4 - 3\n2 * 7\n13 / 3\n-42\n(1 + 2) * 3", 
            "title": "Operations"
        }, 
        {
            "location": "/guides/language_reference/#events", 
            "text": "Statement  Events are containers for related information. One event can extend another one\nby using the keyword  extends . The event declaration has the following\nstructure:   An event has to start with the keyword  event  followed by a whitespaces  The second part has to be a  Type  as referred above   The third part and the fourth part are optional for event inheritance.   The keyword  extends  Type  of the extended event   The following parts are mandatory and define a comma separated list of event\nmembers holding the actual information and are encapsulated by curly braces\n( {} ).   Opening curly brace  {  Comma separated list of identifiers as described above  Closing curly brace  }   Example:  event SampleEvent { position, time };\nevent RangeEvent extends SampleEvent { range };  For inheritance, only new members are allowed to be added in the inherited\nevent. It is forbidden to declare the same member in both, the event and it's\ninheritance.  To define an event with content, you enclose the information with curly braces.   Opening curly brace ( { )   The following is a comma separated list:   Identifier  Equal sign ( = )   Vector    Closing curly brace ( } )    Example:  {\n    position = event_a.position + event_b.position,\n    time = event_a.time + [1.34]\n}", 
            "title": "Events"
        }, 
        {
            "location": "/guides/language_reference/#predicates", 
            "text": "Statement  Predicates are operating on events passed to them. They return either False  or  True . The return value is generated by the comparison\napplied to the predicate. A predicate has to take at least on event as an\nargument. The expression assigned to the predicate has to be a single comparison\nas described above. Predicates are created as below:   A predicate has to start with the keyword  predicate  followed by a\nwhitespace  The second is an  identifier  to name the predicate  Opening parenthesis to begin the list of arguments ( ( )   Arguments are a comma separated list of tuples made out of a  type  and an identifier . Arguments are defined as follows:   Type  as described above  Identifier  as described above   Back to the argument list.   Closing parenthesis to end the list of arguments ( ) )   To separate the predicate definition from it's comparison expression,  \"define\" \n( := ) is used.   Define sign ( := )  Comparison as explained above   Example:  predicate a_predicate(SampleEvent e) := e.position == [1, 1, 1];\npredicate b_predicate(SampleEvent e, RangeEvent r) := e.position != r.position;", 
            "title": "Predicates"
        }, 
        {
            "location": "/guides/language_reference/#functions", 
            "text": "Statement  Functions are also operating on events passed to them. A function must have a\nreturn type. Functions are created as follows:   A function starts with a  type  as described earlier  The second is an  identifier  which names the function  Opening parenthesis to begin the list of arguments ( ( )   Arguments are a comma separated list of tuples made out of a  type  and an identifier  and optional. Arguments are defined as follows:   Type  as described above  Identifier  as described above   Back to the argument list.   Closing parenthesis to end the list of arguments ( ) )   To separate the function definition from it's expression block,  \"define\" \n( := ) is used.   Define sign ( := )  Expression as described below   An expression can be one of the following:   Function call ( f(x) )  Event ( { position = [1, 2, 3] } )   Example:  SampleEvent function_a(SampleEvent event_a) := {\n    position = event_a.position + [1, 0, 0],\n    time = 6 * event_a.time\n}\n\nSampleEvent function_b(SampleEvent e) := function_a(e);", 
            "title": "Functions"
        }, 
        {
            "location": "/guides/language_reference/#rules", 
            "text": "Rules take a list of event  types , a list of predicates and a call function.   A  type  as rule name  Colon ( : )  Opening square bracket ( [ )   The following is optional:   Comma separated list of event types ( EventA, EventB, ... )   The following is optional:   Colon ( : )  Comma separated list of predicate name  identifiers   The following is mandatory:   Closing square bracket ( ] )  Right arrow ( - )  Function name identifier ( function_a )   Example:  RuleA: [SampleEvent : a_predicate] -  function_b;", 
            "title": "Rules"
        }, 
        {
            "location": "/guides/overview/", 
            "text": "Overview\n\n\nMotivation\n\n\nEvent\n is a language for \nrule based complex-event processing on distributed networks\n. Therefore we need to face several challenges. The event language needs\nto be runnable on targets with varying architectures and computational power. On the one hand \nAtmel\n microcontrollers may be used for simple sensor nodes with little processing power. For these low-end applications the event-processors need to be compiled statically to be run efficiently. In contrast \nARM\n or even \nx86\n nodes take on the more complex processing operations. For these applications just in time compilation may\nbe advantageous, because it allows rules to be added or modified dynamically during\nruntime. For either class there is the necessity of being able to transmit event-programms via network. Our solution is an approach based on the \nLLVM\n compiler infrastructure. LLVM includes libraries and tools\nfacilitating the creation of custom compilers. We use LLVM by emitting its intermediate\nrepresentation (IR) in the code-generation phase of our compiler. This IR can then\nbe translated by the LLVM to numerous platform specific assembler languages.\nThis allows us to address the different targets in the embedded network without having\nto create separate code-generators for each target. The resulting binary obejct files\ncan then be transmitted via the network to the nodes. There, the contained event-processors can be employed to process, exchange and generate new events.\n\n\nThe following graphic illustrates this approach:\n\n\n\n\nCore Concepts\n\n\nThe \nEvent\n language is comprised of four toplevel constructs. Together these\nform an intuitive way of describing how events should be processed:\n\n\n\n\nEvents\n (\nSyntax\n) are the currency of data.\nProcessing and generating events, is the main task of this language. Events are\ndefined as composite types featuring an arbitrary number of vector fields.\nEvents can inherit other events, meaning that the parent-event's fields are\nprepended to the child-event's fields. An event of a child type may be used\nanywhere where an event of its parent type is valid.\n\n\nFunctions\n (\nSyntax\n) receive a set of events\nas input and use them to construct a new event. The input events remain unmodified.\n\n\nPredicates\n (\nSyntax\n) like functions receive\na set of events as input and use them to generate a boolean decision based on\nthe values of the input events' fields.\n\n\n\n\nRules\n (\nSyntax\n) combine the previous three\nelements to define in which way events are processed. They consist of:\n\n\n\n\nEvent types\n defining \nwhat\n may be processed\n\n\nPredicates\n defining \nif\n it is to be processed\n\n\nA \nFunction\n defining \nhow\n it is to be processed.", 
            "title": "Overview"
        }, 
        {
            "location": "/guides/overview/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/guides/overview/#motivation", 
            "text": "Event  is a language for  rule based complex-event processing on distributed networks . Therefore we need to face several challenges. The event language needs\nto be runnable on targets with varying architectures and computational power. On the one hand  Atmel  microcontrollers may be used for simple sensor nodes with little processing power. For these low-end applications the event-processors need to be compiled statically to be run efficiently. In contrast  ARM  or even  x86  nodes take on the more complex processing operations. For these applications just in time compilation may\nbe advantageous, because it allows rules to be added or modified dynamically during\nruntime. For either class there is the necessity of being able to transmit event-programms via network. Our solution is an approach based on the  LLVM  compiler infrastructure. LLVM includes libraries and tools\nfacilitating the creation of custom compilers. We use LLVM by emitting its intermediate\nrepresentation (IR) in the code-generation phase of our compiler. This IR can then\nbe translated by the LLVM to numerous platform specific assembler languages.\nThis allows us to address the different targets in the embedded network without having\nto create separate code-generators for each target. The resulting binary obejct files\ncan then be transmitted via the network to the nodes. There, the contained event-processors can be employed to process, exchange and generate new events.  The following graphic illustrates this approach:", 
            "title": "Motivation"
        }, 
        {
            "location": "/guides/overview/#core-concepts", 
            "text": "The  Event  language is comprised of four toplevel constructs. Together these\nform an intuitive way of describing how events should be processed:   Events  ( Syntax ) are the currency of data.\nProcessing and generating events, is the main task of this language. Events are\ndefined as composite types featuring an arbitrary number of vector fields.\nEvents can inherit other events, meaning that the parent-event's fields are\nprepended to the child-event's fields. An event of a child type may be used\nanywhere where an event of its parent type is valid.  Functions  ( Syntax ) receive a set of events\nas input and use them to construct a new event. The input events remain unmodified.  Predicates  ( Syntax ) like functions receive\na set of events as input and use them to generate a boolean decision based on\nthe values of the input events' fields.   Rules  ( Syntax ) combine the previous three\nelements to define in which way events are processed. They consist of:   Event types  defining  what  may be processed  Predicates  defining  if  it is to be processed  A  Function  defining  how  it is to be processed.", 
            "title": "Core Concepts"
        }, 
        {
            "location": "/development/components/", 
            "text": "Components\n\n\nevc.c\n\n\nevc.c\n is the main source file for the compiler. It handles the command\nline parsing and executes the lower level functions of the compiler accordingly.\n\n\nThese lower level functions are:\n\n\n\n\nOpening and reading from file input\n\n\nParsing the input and build an abstract syntax tree (AST)\n\n\nLink references to build the scopes\n\n\nValidate the AST for correctness\n\n\nGenerate LLVM-IR or LLVM bytecode (if output file is given)\n\n\n\n\ncompiler.(c|h)\n\n\nThe files \ncompiler.(c|h)\n handles the parsing of the input and creation of\nthe AST. This is done by initializing the lexer with the input string and\npassing every token that is generated by the lexer to the parser. The parser\nthen generates the AST based on it's grammar.\n\n\nThe return is an AST.\n\n\nlexer.l\n\n\nlexer.l\n is the specification for the lexer generator\n\nFlex\n, which is invoked to create C source code\nfor a lexer that generates all necessary token for the parser from the input.\n\n\nThe specification consists of some configuration for the lexer generator and all\nstrings that should be matched as single tokens. Whitespace is ignored and code\ncomments are skipped.\n\n\nparser.y\n\n\nparser.y\n is the specification for\n\nThe LEMON Parser Generator\n which is used to\ngenerate a parser from the grammar of the \nEvent\n language.\n\n\nEach grammar rule consists of left and a right side. The left side represents\nthe name of the generated node in the AST. the right side is a composition of\ncomponents needed to generate that node. Based on the given components the body\nof the rule executes code. Mostly a new node is created by\n\ntree_create_node()\n from the\n\nLibCollect\n. The components are\nintegrated into the new node to build the whole AST. Some rules create scopes\nfor the validation and code generation. Take a look at\n\nScopes\n for more information.\n\n\nparser_signatures.h\n\n\nparser_signatures.h\n contains the prototypes of the generated parser\nfunctions. LEMON does not generate them itself because it doesn't know which\ndata types the tokens will have.\n\n\nparser_state.h\n\n\nparser_state.h\n contains the state of the parser at any time. It also holds\na reference to the generated AST for easier handling inside the compiler.\n\n\nast.(c|h)\n\n\nThe files \nast.(c|h)\n define which information the AST is holding. For that,\na \nstruct payload\n is defined which is inserted into a new tree node. The\npayload contains following information:\n\n\n\n\nThe type of the node (e.g. N_RULE_DECLARATION)\n\n\nThe alternative to represent the type of the nodes children (e.g. ALT_IDENTIFIER)\n\n\nCustom data depending on the nodes type\n\n\n\n\nThe custom data can hold:\n\n\n\n\nSimple data (e.g. string, int, ...)\n\n\nScopes\n\n\nReferences to other nodes\n\n\n\n\nscope.(c|h)\n\n\nThe files \nscope.(c|h)\n provide functions to create the scopes and references\nfrom the information in the AST. The most important function is\n\nlink_references()\n. It iterates over the tree and visits every node. For\nevery node it resolves necessary references by search the tree in parent\ndirection until it founds the valid node. That scoping is later used by the\nvalidator and the code generator.\n\n\nvalidator.(c|h)\n\n\nvalidator.(c|h)\n is used to check if the AST and it's scopes and references\nare created according to our language definition. For that it provides a single\nfunction \nvalidate()\n that iterates over the tree and perform the necessary\nchecks for every node. The checks are more or less complicated. Take a look into\nthe comments of the source code to learn more about the validation.\n\n\ncodegen.(c|h)\n\n\ncodegen.(c|h)\n generates an LLVM module from the AST. The function\n\ngenerate_module()\n iterates over all declarations and recursively generates\nthe necessary LLVM-IR for every sub-tree node.\n\n\noperators.(c|h)\n\n\nThe files \noperators.(c|h)\n constitute the standard library for the\n\nEvent\n language. It has to be shipped with a compiled \nEvent\n program.\nThe following operators are implemented:\n\n\n\n\nop_v_eq_v()\n : vector equals vector\n\n\nop_v_neq_v()\n : vector not equals vector\n\n\nop_v_add_v()\n : add vector to vector\n\n\nop_v_sub_v()\n : subtract vector from vector\n\n\nop_s_mult_v()\n : multiply a scalar with a vector\n\n\nop_v_lt_v()\n : vector less than vector for every component\n\n\nop_v_gt_v()\n : vector greater than vector for every component\n\n\nop_i_eq_i()\n : integer equals integer", 
            "title": "Components"
        }, 
        {
            "location": "/development/components/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/development/components/#evcc", 
            "text": "evc.c  is the main source file for the compiler. It handles the command\nline parsing and executes the lower level functions of the compiler accordingly.  These lower level functions are:   Opening and reading from file input  Parsing the input and build an abstract syntax tree (AST)  Link references to build the scopes  Validate the AST for correctness  Generate LLVM-IR or LLVM bytecode (if output file is given)", 
            "title": "evc.c"
        }, 
        {
            "location": "/development/components/#compilerch", 
            "text": "The files  compiler.(c|h)  handles the parsing of the input and creation of\nthe AST. This is done by initializing the lexer with the input string and\npassing every token that is generated by the lexer to the parser. The parser\nthen generates the AST based on it's grammar.  The return is an AST.", 
            "title": "compiler.(c|h)"
        }, 
        {
            "location": "/development/components/#lexerl", 
            "text": "lexer.l  is the specification for the lexer generator Flex , which is invoked to create C source code\nfor a lexer that generates all necessary token for the parser from the input.  The specification consists of some configuration for the lexer generator and all\nstrings that should be matched as single tokens. Whitespace is ignored and code\ncomments are skipped.", 
            "title": "lexer.l"
        }, 
        {
            "location": "/development/components/#parsery", 
            "text": "parser.y  is the specification for The LEMON Parser Generator  which is used to\ngenerate a parser from the grammar of the  Event  language.  Each grammar rule consists of left and a right side. The left side represents\nthe name of the generated node in the AST. the right side is a composition of\ncomponents needed to generate that node. Based on the given components the body\nof the rule executes code. Mostly a new node is created by tree_create_node()  from the LibCollect . The components are\nintegrated into the new node to build the whole AST. Some rules create scopes\nfor the validation and code generation. Take a look at Scopes  for more information.", 
            "title": "parser.y"
        }, 
        {
            "location": "/development/components/#parser_signaturesh", 
            "text": "parser_signatures.h  contains the prototypes of the generated parser\nfunctions. LEMON does not generate them itself because it doesn't know which\ndata types the tokens will have.", 
            "title": "parser_signatures.h"
        }, 
        {
            "location": "/development/components/#parser_stateh", 
            "text": "parser_state.h  contains the state of the parser at any time. It also holds\na reference to the generated AST for easier handling inside the compiler.", 
            "title": "parser_state.h"
        }, 
        {
            "location": "/development/components/#astch", 
            "text": "The files  ast.(c|h)  define which information the AST is holding. For that,\na  struct payload  is defined which is inserted into a new tree node. The\npayload contains following information:   The type of the node (e.g. N_RULE_DECLARATION)  The alternative to represent the type of the nodes children (e.g. ALT_IDENTIFIER)  Custom data depending on the nodes type   The custom data can hold:   Simple data (e.g. string, int, ...)  Scopes  References to other nodes", 
            "title": "ast.(c|h)"
        }, 
        {
            "location": "/development/components/#scopech", 
            "text": "The files  scope.(c|h)  provide functions to create the scopes and references\nfrom the information in the AST. The most important function is link_references() . It iterates over the tree and visits every node. For\nevery node it resolves necessary references by search the tree in parent\ndirection until it founds the valid node. That scoping is later used by the\nvalidator and the code generator.", 
            "title": "scope.(c|h)"
        }, 
        {
            "location": "/development/components/#validatorch", 
            "text": "validator.(c|h)  is used to check if the AST and it's scopes and references\nare created according to our language definition. For that it provides a single\nfunction  validate()  that iterates over the tree and perform the necessary\nchecks for every node. The checks are more or less complicated. Take a look into\nthe comments of the source code to learn more about the validation.", 
            "title": "validator.(c|h)"
        }, 
        {
            "location": "/development/components/#codegench", 
            "text": "codegen.(c|h)  generates an LLVM module from the AST. The function generate_module()  iterates over all declarations and recursively generates\nthe necessary LLVM-IR for every sub-tree node.", 
            "title": "codegen.(c|h)"
        }, 
        {
            "location": "/development/components/#operatorsch", 
            "text": "The files  operators.(c|h)  constitute the standard library for the Event  language. It has to be shipped with a compiled  Event  program.\nThe following operators are implemented:   op_v_eq_v()  : vector equals vector  op_v_neq_v()  : vector not equals vector  op_v_add_v()  : add vector to vector  op_v_sub_v()  : subtract vector from vector  op_s_mult_v()  : multiply a scalar with a vector  op_v_lt_v()  : vector less than vector for every component  op_v_gt_v()  : vector greater than vector for every component  op_i_eq_i()  : integer equals integer", 
            "title": "operators.(c|h)"
        }, 
        {
            "location": "/development/scopes/", 
            "text": "Scopes\n\n\nScopes are nested namespaces which are used to link references within the ast to\ntheir corresponding declarations. Therefore within each scope names must be unique.\n\n\nGlobal scope\n\n\n\n\npredicate_definition\n\n\nfunction_definition\n\n\nevent_declaration\n\n\n(rule_declaration : is not needed)\n\n\n\n\nLocal scopes\n\n\nevent_declaration\n\n\n\n\nmember (IDENTIFIER)\n\n\n\n\nrule_declaration\n\n\n\n\nevent (TYPE)\n\n\n\n\npredicate_definition\n\n\n\n\nparameter (IDENTIFIER)\n\n\n\n\nfunction_definition\n\n\n\n\nparameter (IDENTIFIER)", 
            "title": "Scopes"
        }, 
        {
            "location": "/development/scopes/#scopes", 
            "text": "Scopes are nested namespaces which are used to link references within the ast to\ntheir corresponding declarations. Therefore within each scope names must be unique.", 
            "title": "Scopes"
        }, 
        {
            "location": "/development/scopes/#global-scope", 
            "text": "predicate_definition  function_definition  event_declaration  (rule_declaration : is not needed)", 
            "title": "Global scope"
        }, 
        {
            "location": "/development/scopes/#local-scopes", 
            "text": "event_declaration   member (IDENTIFIER)   rule_declaration   event (TYPE)   predicate_definition   parameter (IDENTIFIER)   function_definition   parameter (IDENTIFIER)", 
            "title": "Local scopes"
        }
    ]
}